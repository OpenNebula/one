#!/usr/bin/env python3
# Copyright 2002-2025, OpenNebula Project, OpenNebula Systems
#
# Generate GRPC_API_REGISTRY for gRPC from C++ header files (Option B).
# Parses RequestGRPC("one.{namespace}.{method}", "/one.{package}.{Service}/{Rpc}")
# in src/rm/grpc/*ServiceGRPC.h and produces pyone/grpc/grpc_api_registry.py.
#
# Usage: python tools/generate_grpc_registry.py --grpc-dir src/rm/grpc [--output pyone/grpc/grpc_api_registry.py]
# Run from src/oca/python/ directory.

import argparse
import re
import sys
from pathlib import Path
from typing import TypedDict


class _RegistryEntry(TypedDict):
    namespace: str
    method: str
    proto_package: str
    service: str
    rpc: str
    grpc_path: str


def parse_headers(grpc_dir: Path) -> tuple[list[_RegistryEntry], list[tuple[str, str]], dict[str, int]]:
    """
    Parse all *ServiceGRPC.h files for RequestGRPC calls.
    Returns list of {namespace, method, proto_package, service, rpc, grpc_path}.
    """
    pattern = re.compile(
        r'RequestGRPC\s*\(\s*"one\.([^"]+)"\s*,\s*"([^"]+)"\s*\)'
    )
    entries = []
    seen = set()
    duplicates = []

    for hfile in sorted(grpc_dir.glob("*ServiceGRPC.h")):
        content = hfile.read_text(encoding="utf-8", errors="replace")
        for m in pattern.finditer(content):
            xmlrpc_path = m.group(1)  # e.g. "host.allocate" or "hostpool.info"
            grpc_path = m.group(2)    # e.g. "/one.host.HostService/Allocate"

            # Parse grpc path: /one.{package}.{Service}/{Rpc}
            grpc_match = re.match(r"/one\.([^.]+)\.([^/]+)/(.+)$", grpc_path)
            if not grpc_match:
                continue
            proto_package = grpc_match.group(1)
            service = grpc_match.group(2)
            rpc = grpc_match.group(3)

            # Parse xmlrpc path: "host.allocate" -> namespace=host, method=allocate
            parts = xmlrpc_path.split(".", 1)
            if len(parts) != 2:
                continue
            namespace, method = parts

            # Quota RPC naming mismatch: headers use QuotaInfo/QuotaUpdate while
            # proto defines DefaultQuotaInfo/DefaultQuotaUpdate.
            if namespace in ("groupquota", "userquota"):
                if rpc == "QuotaInfo":
                    rpc = "DefaultQuotaInfo"
                    grpc_path = grpc_path.rsplit("/", 1)[0] + "/" + rpc
                elif rpc == "QuotaUpdate":
                    rpc = "DefaultQuotaUpdate"
                    grpc_path = grpc_path.rsplit("/", 1)[0] + "/" + rpc

            # Heuristic: C++ HostPoolMonitoringGRPC uses "one.host.monitoring" for
            # PoolMonitoring RPC - PyONE expects hostpool.monitoring. When RPC
            # starts with "Pool" and namespace doesn't already end with "pool",
            # use namespace+pool and derive method from RPC.
            if (
                rpc.startswith("Pool")
                and not namespace.endswith("pool")
                and len(rpc) > 4
            ):
                pool_method = rpc[4:].lower()
                namespace = namespace + "pool"
                method = pool_method

                if namespace == "marketpoolapppool":
                    namespace = "marketapppool"

            key = (namespace, method)
            if key in seen:
                duplicates.append(key)
                continue
            seen.add(key)

            entries.append({
                "namespace": namespace,
                "method": method,
                "proto_package": proto_package,
                "service": service,
                "rpc": rpc,
                "grpc_path": grpc_path,
            })

    return entries, duplicates


def build_registry(entries: list[_RegistryEntry]) -> dict[tuple[str, str], dict[str, str]]:
    """Build GRPC_API_REGISTRY dict from parsed entries (header-only)."""
    registry = {}

    for e in entries:
        ns, method = e["namespace"], e["method"]
        proto_pkg = e["proto_package"]
        service = e["service"]
        rpc = e["rpc"]

        registry[(ns, method)] = {
            "proto_package": proto_pkg,
            "service": service,
            "rpc": rpc,
            "grpc_path": e["grpc_path"],
        }

    return registry


def generate_grpc_api_registry(registry: dict[tuple[str, str], dict[str, str]], output_path: Path) -> None:
    """Write grpc_api_registry.py with GRPC_API_REGISTRY (header-only)."""
    lines = [
        "# Copyright 2002-2025, OpenNebula Project, OpenNebula Systems",
        "#",
        "# AUTO-GENERATED by tools/generate_grpc_registry.py - DO NOT EDIT MANUALLY",
        "#",
        "# Declarative mapping: (namespace, method) -> gRPC service/RPC (header-only).",
        "# Regenerate with: python tools/generate_grpc_registry.py",
        "#",
        "# Each entry:",
        "#   proto_package: proto package (e.g. host, vm, tmpl)",
        "#   service: gRPC service name (e.g. HostService, VirtualMachineService)",
        "#   rpc: gRPC method name (Allocate, Info, PoolInfo, etc.)",
        "#   grpc_path: full gRPC method path (for debugging)",
        "#",
        "",
    ]

    lines.append("# Registry: (namespace, method) -> {proto_package, service, rpc, grpc_path}")
    lines.append("GRPC_API_REGISTRY = {")

    for (ns, method), spec in sorted(registry.items(), key=lambda x: (x[0][0], x[0][1])):
        lines.append(f'    ("{ns}", "{method}"): {{')
        lines.append(f'        "proto_package": "{spec["proto_package"]}",')
        lines.append(f'        "service": "{spec["service"]}",')
        lines.append(f'        "rpc": "{spec["rpc"]}",')
        lines.append(f'        "grpc_path": "{spec["grpc_path"]}",')
        lines.append("    },")

    lines.append("}")
    lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {output_path} ({len(registry)} entries)")


def main():
    parser = argparse.ArgumentParser(
        description="Generate GRPC_API_REGISTRY from C++ gRPC headers"
    )
    parser.add_argument(
        "--output",
        "-o",
        default="./grpc_api_registry.py",
        help="Output path for grpc_api_registry.py",
    )
    parser.add_argument(
        "--grpc-dir",
        required=True,
        help="Path to src/rm/grpc",
    )
    args = parser.parse_args()

    grpc_dir = Path(args.grpc_dir)
    output_path = Path(args.output)

    if not grpc_dir.is_dir():
        print(f"Error: grpc dir not found: {grpc_dir}", file=sys.stderr)
        sys.exit(1)

    entries, duplicates = parse_headers(grpc_dir)
    if duplicates:
        dup_list = ", ".join(sorted({f"{ns}.{meth}" for ns, meth in duplicates}))
        print(
            f"Warning: duplicate XML-RPC mappings found: {dup_list}",
            file=sys.stderr,
        )
    registry = build_registry(entries)
    generate_grpc_api_registry(registry, output_path)


if __name__ == "__main__":
    main()
